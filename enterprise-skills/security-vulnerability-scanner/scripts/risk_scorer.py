#!/usr/bin/env python3
"""
Risk Scorer
Scores and prioritizes security vulnerabilities
"""

from typing import Dict, List, Any, Tuple
from dataclasses import dataclass

@dataclass
class RiskScore:
    """Risk score for a vulnerability."""
    vulnerability_type: str
    score: float
    exploitability: float
    impact: float
    priority: str

class RiskScorer:
    """Scores and prioritizes vulnerabilities using CVSS-like methodology."""

    def __init__(self):
        # Base scores for vulnerability types
        self.base_scores = {
            "sql_injection": 8.6,
            "command_injection": 8.8,
            "path_traversal": 7.5,
            "xss": 7.3,
            "insecure_deserialization": 9.8,
            "hardcoded_secrets": 8.9,
            "insecure_random": 7.5,
            "weak_cryptography": 7.4,
            "missing_authentication": 8.2,
            "missing_input_validation": 6.5,
        }

    def calculate_cvss_score(self, vulnerability: Dict[str, Any]) -> float:
        """Calculate CVSS-like score for a vulnerability."""
        
        vuln_type = vulnerability.get('type', '')
        base_score = self.base_scores.get(vuln_type, 5.0)
        
        # Adjust based on severity
        severity = vulnerability.get('severity', 'MEDIUM')
        severity_multiplier = {
            'CRITICAL': 1.3,
            'HIGH': 1.1,
            'MEDIUM': 1.0,
            'LOW': 0.8
        }
        
        adjusted_score = base_score * severity_multiplier.get(severity, 1.0)
        
        # Cap at 10.0
        return min(adjusted_score, 10.0)

    def score_vulnerability(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Score a single vulnerability."""
        
        vuln_type = vulnerability.get('type', '')
        cvss_score = self.calculate_cvss_score(vulnerability)
        
        # Calculate exploitability (0-10)
        exploitability = self._calculate_exploitability(vuln_type)
        
        # Calculate impact (0-10)
        impact = self._calculate_impact(vuln_type)
        
        # Determine priority
        priority = self._determine_priority(cvss_score)
        
        return {
            "type": vuln_type,
            "cvss_score": round(cvss_score, 1),
            "exploitability": round(exploitability, 1),
            "impact": round(impact, 1),
            "priority": priority,
            "description": vulnerability.get('description', ''),
            "remediation": vulnerability.get('remediation', ''),
            "cwe_id": vulnerability.get('cwe_id', ''),
        }

    def score_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Score multiple vulnerabilities."""
        
        scored = [self.score_vulnerability(v) for v in vulnerabilities]
        
        # Sort by CVSS score (highest first)
        scored.sort(key=lambda x: x['cvss_score'], reverse=True)
        
        return scored

    def calculate_risk_profile(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Calculate overall risk profile for a codebase."""
        
        if not vulnerabilities:
            return {
                "overall_risk": "LOW",
                "total_vulnerabilities": 0,
                "critical_count": 0,
                "high_count": 0,
                "medium_count": 0,
                "low_count": 0,
                "average_cvss": 0.0,
                "max_cvss": 0.0,
                "recommendations": ["Code is secure"]
            }
        
        scored = self.score_vulnerabilities(vulnerabilities)
        
        # Count by severity
        severity_counts = {
            'CRITICAL': 0,
            'HIGH': 0,
            'MEDIUM': 0,
            'LOW': 0
        }
        
        cvss_scores = []
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'LOW')
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            cvss_score = self.calculate_cvss_score(vuln)
            cvss_scores.append(cvss_score)
        
        # Determine overall risk
        overall_risk = self._determine_overall_risk(severity_counts, cvss_scores)
        
        return {
            "overall_risk": overall_risk,
            "total_vulnerabilities": len(vulnerabilities),
            "critical_count": severity_counts['CRITICAL'],
            "high_count": severity_counts['HIGH'],
            "medium_count": severity_counts['MEDIUM'],
            "low_count": severity_counts['LOW'],
            "average_cvss": round(sum(cvss_scores) / len(cvss_scores), 1),
            "max_cvss": round(max(cvss_scores), 1),
            "min_cvss": round(min(cvss_scores), 1),
            "recommendations": self._generate_recommendations(severity_counts, scored)
        }

    def prioritize_remediation(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Prioritize vulnerabilities for remediation."""
        
        scored = self.score_vulnerabilities(vulnerabilities)
        
        prioritized = []
        for i, vuln in enumerate(scored, 1):
            effort = self._estimate_effort(vuln['type'])
            impact_of_fix = self._estimate_impact_of_fix(vuln['type'])
            
            prioritized.append({
                "rank": i,
                "type": vuln['type'],
                "cvss_score": vuln['cvss_score'],
                "priority": vuln['priority'],
                "description": vuln['description'],
                "remediation": vuln['remediation'],
                "estimated_effort_hours": effort,
                "risk_reduction_percent": impact_of_fix,
                "effort_vs_impact_ratio": round(impact_of_fix / max(effort, 0.1), 2)
            })
        
        return prioritized

    def estimate_business_impact(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Estimate business impact of vulnerabilities."""
        
        risk_profile = self.calculate_risk_profile(vulnerabilities)
        
        # Estimate financial impact
        impact_scores = {
            'CRITICAL': 50000,  # $50K average impact
            'HIGH': 10000,      # $10K average impact
            'MEDIUM': 1000,     # $1K average impact
            'LOW': 100          # $100 average impact
        }
        
        estimated_cost = (
            risk_profile['critical_count'] * impact_scores['CRITICAL'] +
            risk_profile['high_count'] * impact_scores['HIGH'] +
            risk_profile['medium_count'] * impact_scores['MEDIUM'] +
            risk_profile['low_count'] * impact_scores['LOW']
        )
        
        return {
            "estimated_financial_impact": f"${estimated_cost:,}",
            "risk_level": risk_profile['overall_risk'],
            "business_recommendation": self._get_business_recommendation(risk_profile),
            "compliance_risk": self._assess_compliance_risk(vulnerabilities),
            "reputational_risk": self._assess_reputational_risk(vulnerabilities)
        }

    # ===== Private Methods =====

    def _calculate_exploitability(self, vuln_type: str) -> float:
        """Calculate exploitability score (0-10) for a vulnerability type."""
        
        exploitability_scores = {
            "sql_injection": 9.8,      # Very easy to exploit
            "command_injection": 9.9,   # Trivial to exploit
            "path_traversal": 8.5,      # Easy to exploit
            "xss": 8.2,                 # Common to exploit
            "insecure_deserialization": 7.5,  # Requires knowledge
            "hardcoded_secrets": 9.5,   # Easy if found
            "insecure_random": 7.0,     # Requires understanding
            "weak_cryptography": 6.5,   # Requires crypto knowledge
            "missing_authentication": 9.0,  # Easy to exploit
            "missing_input_validation": 8.0,  # Relatively easy
        }
        
        return exploitability_scores.get(vuln_type, 5.0)

    def _calculate_impact(self, vuln_type: str) -> float:
        """Calculate impact score (0-10) for a vulnerability type."""
        
        impact_scores = {
            "sql_injection": 9.5,       # Complete data compromise
            "command_injection": 10.0,  # Complete system compromise
            "path_traversal": 7.5,      # File system access
            "xss": 7.8,                 # Session hijacking possible
            "insecure_deserialization": 10.0,  # Full RCE
            "hardcoded_secrets": 8.5,   # Account compromise
            "insecure_random": 8.0,     # Security bypass
            "weak_cryptography": 8.2,   # Data compromise
            "missing_authentication": 9.5,  # Unauthorized access
            "missing_input_validation": 7.0,  # Various attacks
        }
        
        return impact_scores.get(vuln_type, 5.0)

    def _determine_priority(self, cvss_score: float) -> str:
        """Determine priority based on CVSS score."""
        
        if cvss_score >= 9.0:
            return "CRITICAL"
        elif cvss_score >= 7.0:
            return "HIGH"
        elif cvss_score >= 4.0:
            return "MEDIUM"
        else:
            return "LOW"

    def _determine_overall_risk(self, severity_counts: Dict[str, int], cvss_scores: List[float]) -> str:
        """Determine overall risk level."""
        
        if severity_counts['CRITICAL'] > 0:
            return "CRITICAL"
        elif severity_counts['HIGH'] > 2:
            return "HIGH"
        elif severity_counts['CRITICAL'] == 0 and severity_counts['HIGH'] == 0:
            return "LOW"
        else:
            return "MEDIUM"

    def _estimate_effort(self, vuln_type: str) -> float:
        """Estimate effort in hours to fix vulnerability."""
        
        effort_estimates = {
            "sql_injection": 4.0,       # Change to parameterized queries
            "command_injection": 3.0,   # Use subprocess correctly
            "path_traversal": 3.0,      # Add path validation
            "xss": 2.5,                 # Enable auto-escaping
            "insecure_deserialization": 6.0,  # Change serialization method
            "hardcoded_secrets": 1.5,   # Move to env vars
            "insecure_random": 1.0,     # Import secrets module
            "weak_cryptography": 4.0,   # Update crypto algorithms
            "missing_authentication": 4.0,   # Add auth decorator
            "missing_input_validation": 3.0,  # Add validation
        }
        
        return effort_estimates.get(vuln_type, 3.0)

    def _estimate_impact_of_fix(self, vuln_type: str) -> float:
        """Estimate impact reduction in percent (0-100) from fixing vulnerability."""
        
        impact_of_fix = {
            "sql_injection": 95.0,       # Eliminates injection attacks
            "command_injection": 95.0,   # Eliminates shell attacks
            "path_traversal": 80.0,      # Significantly reduces risk
            "xss": 85.0,                 # Eliminates XSS attacks
            "insecure_deserialization": 95.0,  # Eliminates RCE
            "hardcoded_secrets": 90.0,   # Removes exposure
            "insecure_random": 85.0,     # Improves randomness
            "weak_cryptography": 80.0,   # Strengthens encryption
            "missing_authentication": 95.0,  # Protects resources
            "missing_input_validation": 75.0,  # Reduces attack surface
        }
        
        return impact_of_fix.get(vuln_type, 50.0)

    def _generate_recommendations(self, severity_counts: Dict[str, int], scored: List[Dict]) -> List[str]:
        """Generate recommendations based on vulnerabilities."""
        
        recommendations = []
        
        if severity_counts['CRITICAL'] > 0:
            recommendations.append("URGENT: Address critical vulnerabilities immediately")
        
        if severity_counts['HIGH'] > 0:
            recommendations.append("Address high-severity vulnerabilities within 2 weeks")
        
        if severity_counts['CRITICAL'] == 0 and severity_counts['HIGH'] == 0:
            recommendations.append("Code has acceptable security posture")
        
        if any(v['type'] == 'hardcoded_secrets' for v in scored):
            recommendations.append("Implement secrets management system (e.g., HashiCorp Vault)")
        
        if any(v['type'] == 'missing_input_validation' for v in scored):
            recommendations.append("Establish input validation framework")
        
        return recommendations

    def _get_business_recommendation(self, risk_profile: Dict[str, Any]) -> str:
        """Get business-level recommendation."""
        
        if risk_profile['overall_risk'] == 'CRITICAL':
            return "Do not deploy - fix critical vulnerabilities before release"
        elif risk_profile['overall_risk'] == 'HIGH':
            return "Deploy with risk mitigation plan - address high-severity issues ASAP"
        elif risk_profile['overall_risk'] == 'MEDIUM':
            return "Can deploy with monitoring - schedule remediation"
        else:
            return "Safe to deploy - continue regular security reviews"

    def _assess_compliance_risk(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Assess compliance implications."""
        
        has_injection = any(v['type'] in ['sql_injection', 'command_injection'] for v in vulnerabilities)
        has_auth_issues = any(v['type'] == 'missing_authentication' for v in vulnerabilities)
        has_encryption_issues = any(v['type'] in ['weak_cryptography', 'hardcoded_secrets'] for v in vulnerabilities)
        
        risk_areas = []
        if has_injection:
            risk_areas.append("GDPR - Data protection")
        if has_auth_issues:
            risk_areas.append("PCI-DSS - Access control")
        if has_encryption_issues:
            risk_areas.append("HIPAA - Encryption requirements")
        
        return {
            "compliance_frameworks_at_risk": risk_areas if risk_areas else ["None identified"],
            "audit_difficulty": "HIGH" if risk_areas else "LOW"
        }

    def _assess_reputational_risk(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Assess reputational impact."""
        
        critical_count = sum(1 for v in vulnerabilities if v.get('severity') == 'CRITICAL')
        
        if critical_count > 0:
            return {
                "likelihood_of_breach": "HIGH",
                "potential_user_impact": "Severe data compromise",
                "pr_impact": "Significant - public disclosure likely"
            }
        else:
            return {
                "likelihood_of_breach": "LOW",
                "potential_user_impact": "Limited",
                "pr_impact": "Minimal"
            }


if __name__ == "__main__":
    scorer = RiskScorer()
    
    vulnerabilities = [
        {
            "type": "sql_injection",
            "severity": "CRITICAL",
            "description": "SQL injection in user query",
            "cwe_id": "CWE-89"
        },
        {
            "type": "missing_authentication",
            "severity": "HIGH",
            "description": "API endpoint without auth",
            "cwe_id": "CWE-306"
        }
    ]
    
    risk_profile = scorer.calculate_risk_profile(vulnerabilities)
    prioritized = scorer.prioritize_remediation(vulnerabilities)
    business_impact = scorer.estimate_business_impact(vulnerabilities)
    
    import json
    print(json.dumps({"risk_profile": risk_profile, "prioritized": prioritized, "business_impact": business_impact}, indent=2))
