#!/usr/bin/env python3
"""
Vulnerability Detector
Identifies security vulnerabilities in code
"""

import re
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

class Severity(Enum):
    """Severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

@dataclass
class Vulnerability:
    """A detected vulnerability."""
    type: str
    severity: Severity
    description: str
    location: Optional[str]
    remediation: str
    cwe_id: str

class VulnDetector:
    """Detects security vulnerabilities in code."""

    def __init__(self):
        self.owasp_top_10 = [
            "injection",
            "broken_auth",
            "sensitive_data_exposure",
            "xml_external_entities",
            "broken_access_control",
            "security_misconfiguration",
            "xss",
            "insecure_deserialization",
            "using_components_with_known_vulns",
            "insufficient_logging"
        ]

    def detect_sql_injection(self, code: str) -> List[Dict[str, Any]]:
        """Detect SQL injection vulnerabilities."""
        
        vulns = []
        
        # Pattern 1: String concatenation in SQL
        patterns = [
            (r'query\s*=\s*["\']SELECT.*?\+\s*\w+', "String concatenation in SQL"),
            (r'execute\s*\(\s*["\']SELECT.*?\+', "SQL injection via concatenation"),
            (r'format\s*\(\s*["\']SELECT', "SQL format string injection"),
        ]
        
        for pattern, desc in patterns:
            if re.search(pattern, code, re.IGNORECASE):
                vulns.append({
                    "type": "sql_injection",
                    "severity": "CRITICAL",
                    "cwe_id": "CWE-89",
                    "description": desc,
                    "remediation": "Use parameterized queries or prepared statements"
                })
        
        # Pattern 2: User input in SQL without escaping
        user_input_patterns = [
            r'request\.args\[.*?\]\s*in\s+',
            r'request\.form\[.*?\]\s*in\s+',
            r'user_input\s*in\s+query'
        ]
        
        for pattern in user_input_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                vulns.append({
                    "type": "sql_injection",
                    "severity": "CRITICAL",
                    "cwe_id": "CWE-89",
                    "description": "Unescaped user input in SQL query",
                    "remediation": "Use ORM or parameterized queries"
                })
        
        return vulns

    def detect_command_injection(self, code: str) -> List[Dict[str, Any]]:
        """Detect command injection vulnerabilities."""
        
        vulns = []
        
        # Pattern 1: os.system or subprocess with user input
        patterns = [
            (r'os\.system\s*\(\s*["\'].*?\+\s*\w+', "os.system with string concatenation"),
            (r'subprocess\.run\s*\(\s*["\'].*?\+', "subprocess with concatenated command"),
            (r'os\.popen\s*\(\s*user_input', "os.popen with user input"),
            (r'shell\s*=\s*True', "shell=True in subprocess.run"),
        ]
        
        for pattern, desc in patterns:
            if re.search(pattern, code, re.IGNORECASE):
                vulns.append({
                    "type": "command_injection",
                    "severity": "CRITICAL",
                    "cwe_id": "CWE-78",
                    "description": desc,
                    "remediation": "Use subprocess with shell=False and list arguments"
                })
        
        return vulns

    def detect_path_traversal(self, code: str) -> List[Dict[str, Any]]:
        """Detect path traversal vulnerabilities."""
        
        vulns = []
        
        # Pattern 1: Direct file access with user input
        patterns = [
            (r'open\s*\(\s*user_input', "Direct open() with user input"),
            (r'open\s*\(\s*request\.args', "File open with request argument"),
            (r'os\.path\.join\s*\(\s*base_dir\s*,\s*user_input', "Path join without normalization"),
        ]
        
        for pattern, desc in patterns:
            if re.search(pattern, code, re.IGNORECASE):
                vulns.append({
                    "type": "path_traversal",
                    "severity": "HIGH",
                    "cwe_id": "CWE-22",
                    "description": desc,
                    "remediation": "Validate and normalize file paths, use whitelist"
                })
        
        # Pattern 2: .. in path
        if '..' in code and ('open' in code or 'join' in code):
            vulns.append({
                "type": "path_traversal",
                "severity": "HIGH",
                "cwe_id": "CWE-22",
                "description": "Potential path traversal with .. detected",
                "remediation": "Validate file paths against whitelist"
            })
        
        return vulns

    def detect_xss_vulnerabilities(self, code: str) -> List[Dict[str, Any]]:
        """Detect Cross-Site Scripting (XSS) vulnerabilities."""
        
        vulns = []
        
        # Pattern 1: Unescaped output in templates
        patterns = [
            (r'{{\s*\w+\s*}}', "Unescaped template variable in Jinja2"),
            (r'f["\'].*?{.*?}', "f-string with unsanitized user input"),
            (r'render_template\s*\(\s*["\'].*?\+', "Template rendering with concatenation"),
        ]
        
        for pattern, desc in patterns:
            if re.search(pattern, code):
                vulns.append({
                    "type": "xss",
                    "severity": "HIGH",
                    "cwe_id": "CWE-79",
                    "description": desc,
                    "remediation": "Use template auto-escaping or sanitize user input"
                })
        
        # Pattern 2: innerHTML with user data
        if re.search(r'\.innerHTML\s*=\s*.*?user_input', code):
            vulns.append({
                "type": "xss",
                "severity": "HIGH",
                "cwe_id": "CWE-79",
                "description": "innerHTML assignment with user input",
                "remediation": "Use textContent or sanitize HTML input"
            })
        
        return vulns

    def detect_insecure_deserialization(self, code: str) -> List[Dict[str, Any]]:
        """Detect insecure deserialization vulnerabilities."""
        
        vulns = []
        
        # Pattern 1: pickle with untrusted data
        patterns = [
            (r'pickle\.loads\s*\(\s*user_input', "pickle.loads with user input"),
            (r'pickle\.load\s*\(\s*request', "pickle.load from request"),
            (r'yaml\.load\s*\(\s*[^,]*?\)', "yaml.load without Loader"),
        ]
        
        for pattern, desc in patterns:
            if re.search(pattern, code):
                vulns.append({
                    "type": "insecure_deserialization",
                    "severity": "CRITICAL",
                    "cwe_id": "CWE-502",
                    "description": desc,
                    "remediation": "Use safer alternatives like json or specify safe Loader"
                })
        
        # Pattern 2: eval/exec with user input
        if re.search(r'eval\s*\(\s*\w+\s*\)', code) or re.search(r'exec\s*\(\s*\w+\s*\)', code):
            vulns.append({
                "type": "insecure_deserialization",
                "severity": "CRITICAL",
                "cwe_id": "CWE-502",
                "description": "eval() or exec() with potentially untrusted input",
                "remediation": "Never use eval/exec; use safer alternatives"
            })
        
        return vulns

    def detect_hardcoded_secrets(self, code: str) -> List[Dict[str, Any]]:
        """Detect hardcoded secrets in code."""
        
        vulns = []
        
        # Pattern 1: Hardcoded API keys
        patterns = [
            (r'api_key\s*=\s*["\'][A-Za-z0-9]{20,}', "Hardcoded API key"),
            (r'password\s*=\s*["\'][^"\']+["\']', "Hardcoded password"),
            (r'secret\s*=\s*["\'][^"\']+["\']', "Hardcoded secret"),
            (r'token\s*=\s*["\']sk_[^"\']*', "Hardcoded authentication token"),
            (r'aws_secret_access_key\s*=', "Hardcoded AWS secret"),
        ]
        
        for pattern, desc in patterns:
            if re.search(pattern, code, re.IGNORECASE):
                vulns.append({
                    "type": "hardcoded_secrets",
                    "severity": "CRITICAL",
                    "cwe_id": "CWE-798",
                    "description": desc,
                    "remediation": "Use environment variables or secrets management"
                })
        
        return vulns

    def detect_insecure_random(self, code: str) -> List[Dict[str, Any]]:
        """Detect use of insecure random number generation."""
        
        vulns = []
        
        # Pattern: Using random instead of secrets
        if re.search(r'random\.choice\s*\(\s*\w+\s*\)', code) and 'secret' in code.lower():
            vulns.append({
                "type": "insecure_random",
                "severity": "HIGH",
                "cwe_id": "CWE-338",
                "description": "Using random module for security-sensitive values",
                "remediation": "Use secrets module instead of random"
            })
        
        if re.search(r'random\.randint\s*\(\s*', code) and 'token' in code.lower():
            vulns.append({
                "type": "insecure_random",
                "severity": "HIGH",
                "cwe_id": "CWE-338",
                "description": "random.randint used for security token generation",
                "remediation": "Use secrets.randbelow() instead"
            })
        
        return vulns

    def detect_weak_cryptography(self, code: str) -> List[Dict[str, Any]]:
        """Detect weak cryptography usage."""
        
        vulns = []
        
        # Pattern 1: Weak hash functions
        weak_hashes = ['md5', 'sha1']
        for weak_hash in weak_hashes:
            if re.search(f'hashlib\\.{weak_hash}\\s*\\(', code):
                vulns.append({
                    "type": "weak_cryptography",
                    "severity": "HIGH",
                    "cwe_id": "CWE-327",
                    "description": f"Using weak hash function: {weak_hash}",
                    "remediation": "Use SHA-256 or SHA-512 instead"
                })
        
        # Pattern 2: ECB mode (weak cipher mode)
        if re.search(r'AES\.MODE_ECB', code):
            vulns.append({
                "type": "weak_cryptography",
                "severity": "HIGH",
                "cwe_id": "CWE-327",
                "description": "Using ECB mode (deterministic and weak)",
                "remediation": "Use CBC or GCM mode instead"
            })
        
        # Pattern 3: No IV/nonce
        if re.search(r'Cipher\\.new\s*\(\s*AES', code) and 'iv' not in code.lower():
            vulns.append({
                "type": "weak_cryptography",
                "severity": "HIGH",
                "cwe_id": "CWE-327",
                "description": "Cipher created without IV/nonce",
                "remediation": "Always use a random IV/nonce"
            })
        
        return vulns

    def detect_missing_authentication(self, code: str) -> List[Dict[str, Any]]:
        """Detect missing authentication checks."""
        
        vulns = []
        
        # Pattern 1: Routes without authentication
        if re.search(r'@app\.route\s*\(', code) and 'auth' not in code.lower():
            if not re.search(r'@login_required', code):
                vulns.append({
                    "type": "missing_authentication",
                    "severity": "HIGH",
                    "cwe_id": "CWE-306",
                    "description": "Route defined without authentication check",
                    "remediation": "Add @login_required or equivalent authentication check"
                })
        
        # Pattern 2: API endpoints without authentication
        if 'api' in code.lower() and '@' in code:
            if not re.search(r'authenticate|verify_token|@login_required', code):
                vulns.append({
                    "type": "missing_authentication",
                    "severity": "HIGH",
                    "cwe_id": "CWE-306",
                    "description": "API endpoint without authentication",
                    "remediation": "Add authentication middleware or decorator"
                })
        
        return vulns

    def detect_missing_input_validation(self, code: str) -> List[Dict[str, Any]]:
        """Detect missing input validation."""
        
        vulns = []
        
        # Pattern 1: request.args/form without validation
        if re.search(r'request\.(args|form)\[', code):
            if not re.search(r'validate|check|sanitize', code.lower()):
                vulns.append({
                    "type": "missing_input_validation",
                    "severity": "MEDIUM",
                    "cwe_id": "CWE-20",
                    "description": "User input from request without validation",
                    "remediation": "Validate and sanitize all user inputs"
                })
        
        return vulns

    def detect_all_vulnerabilities(self, code: str) -> List[Dict[str, Any]]:
        """Detect all known vulnerabilities in code."""
        
        all_vulns = []
        
        detectors = [
            self.detect_sql_injection,
            self.detect_command_injection,
            self.detect_path_traversal,
            self.detect_xss_vulnerabilities,
            self.detect_insecure_deserialization,
            self.detect_hardcoded_secrets,
            self.detect_insecure_random,
            self.detect_weak_cryptography,
            self.detect_missing_authentication,
            self.detect_missing_input_validation,
        ]
        
        for detector in detectors:
            all_vulns.extend(detector(code))
        
        # Remove duplicates and sort by severity
        seen = set()
        unique_vulns = []
        for vuln in all_vulns:
            key = (vuln['type'], vuln['description'])
            if key not in seen:
                seen.add(key)
                unique_vulns.append(vuln)
        
        # Sort by severity
        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
        unique_vulns.sort(key=lambda x: severity_order.get(x['severity'], 4))
        
        return unique_vulns

    def get_owasp_mapping(self, vuln_type: str) -> str:
        """Map vulnerability to OWASP Top 10."""
        
        mapping = {
            "sql_injection": "A03:2021 – Injection",
            "command_injection": "A03:2021 – Injection",
            "path_traversal": "A01:2021 – Broken Access Control",
            "xss": "A07:2021 – Cross-Site Scripting (XSS)",
            "insecure_deserialization": "A08:2021 – Software and Data Integrity Failures",
            "hardcoded_secrets": "A02:2021 – Cryptographic Failures",
            "insecure_random": "A02:2021 – Cryptographic Failures",
            "weak_cryptography": "A02:2021 – Cryptographic Failures",
            "missing_authentication": "A07:2021 – Identification and Authentication Failures",
            "missing_input_validation": "A03:2021 – Injection",
        }
        
        return mapping.get(vuln_type, "Unknown OWASP Category")


if __name__ == "__main__":
    detector = VulnDetector()
    
    vulnerable_code = """
    import os
    def get_user_data(user_id):
        query = "SELECT * FROM users WHERE id = " + user_id
        db.execute(query)
        
        file_path = "/data/" + request.args['file']
        with open(file_path) as f:
            return f.read()
    """
    
    vulns = detector.detect_all_vulnerabilities(vulnerable_code)
    
    import json
    print(json.dumps(vulns, indent=2))
