#!/usr/bin/env python3
"""
CVE Checker
Checks for known vulnerabilities in dependencies
"""

from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

@dataclass
class CVE:
    """Common Vulnerabilities and Exposures entry."""
    cve_id: str
    package: str
    version: str
    severity: str
    description: str
    affected_versions: List[str]
    fixed_version: str
    cvss_score: float
    publication_date: str
    cwe_ids: List[str]

class CVEChecker:
    """Checks dependencies for known CVEs."""

    def __init__(self):
        # Simulated CVE database (in production, would fetch from NVD)
        self.cve_database = self._load_cve_database()

    def check_package(self, package_name: str, version: str) -> List[CVE]:
        """Check a package for known CVEs."""
        
        vulns = []
        
        for cve in self.cve_database:
            if cve['package'].lower() == package_name.lower():
                if self._is_vulnerable(version, cve['affected_versions']):
                    vulns.append(cve)
        
        return vulns

    def check_requirements_file(self, requirements: Dict[str, str]) -> Dict[str, Any]:
        """Check all packages in requirements."""
        
        all_vulns = []
        vulnerable_packages = []
        summary = {
            "total_packages": len(requirements),
            "vulnerable_packages": 0,
            "vulnerabilities_found": 0,
            "critical_count": 0,
            "high_count": 0,
            "medium_count": 0,
            "low_count": 0
        }
        
        for package, version in requirements.items():
            vulns = self.check_package(package, version)
            if vulns:
                vulnerable_packages.append({
                    "package": package,
                    "installed_version": version,
                    "vulnerabilities": vulns
                })
                all_vulns.extend(vulns)
                summary["vulnerable_packages"] += 1
        
        # Count by severity
        for vuln in all_vulns:
            severity = vuln.get('severity', 'LOW')
            summary[f"{severity.lower()}_count"] = summary.get(f"{severity.lower()}_count", 0) + 1
        
        summary["vulnerabilities_found"] = len(all_vulns)
        
        return {
            "summary": summary,
            "vulnerable_packages": vulnerable_packages,
            "recommendations": self._generate_upgrade_recommendations(vulnerable_packages)
        }

    def check_package_vulnerability_history(self, package: str) -> Dict[str, Any]:
        """Get vulnerability history for a package."""
        
        vulns = [cve for cve in self.cve_database if cve['package'].lower() == package.lower()]
        
        # Sort by publication date
        vulns.sort(key=lambda x: x['publication_date'], reverse=True)
        
        return {
            "package": package,
            "total_cves": len(vulns),
            "vulnerabilities": vulns,
            "risk_level": self._assess_package_risk(vulns),
            "recommendation": self._recommend_package_usage(vulns)
        }

    def generate_sbom(self, requirements: Dict[str, str]) -> Dict[str, Any]:
        """Generate Software Bill of Materials (SBOM) with security info."""
        
        components = []
        
        for package, version in requirements.items():
            vulns = self.check_package(package, version)
            
            component = {
                "type": "library",
                "package": package,
                "version": version,
                "vulnerabilities": len(vulns),
                "cves": [v['cve_id'] for v in vulns] if vulns else []
            }
            
            components.append(component)
        
        return {
            "format": "CycloneDX",
            "bom_version": "1.4",
            "spec_version": "1.4",
            "components": components,
            "metadata": {
                "timestamp": "2024-01-01T00:00:00Z",
                "total_components": len(components),
                "total_cves": sum(c['vulnerabilities'] for c in components)
            }
        }

    def generate_vulnerability_report(self, requirements: Dict[str, str]) -> str:
        """Generate a human-readable vulnerability report."""
        
        check_result = self.check_requirements_file(requirements)
        summary = check_result['summary']
        
        report = "# Dependency Vulnerability Report\n\n"
        
        # Summary section
        report += "## Summary\n"
        report += f"- Total Packages: {summary['total_packages']}\n"
        report += f"- Vulnerable Packages: {summary['vulnerable_packages']}\n"
        report += f"- Total Vulnerabilities: {summary['vulnerabilities_found']}\n"
        report += f"  - Critical: {summary['critical_count']}\n"
        report += f"  - High: {summary['high_count']}\n"
        report += f"  - Medium: {summary['medium_count']}\n"
        report += f"  - Low: {summary['low_count']}\n\n"
        
        # Vulnerable packages section
        if check_result['vulnerable_packages']:
            report += "## Vulnerable Packages\n\n"
            
            for pkg_info in check_result['vulnerable_packages']:
                report += f"### {pkg_info['package']} (Current: {pkg_info['installed_version']})\n\n"
                
                for vuln in pkg_info['vulnerabilities']:
                    report += f"- **{vuln['cve_id']}** ({vuln['severity']})\n"
                    report += f"  - CVSS Score: {vuln['cvss_score']}/10\n"
                    report += f"  - Description: {vuln['description']}\n"
                    report += f"  - Fixed in: {vuln['fixed_version']}\n\n"
        
        # Recommendations
        report += "## Recommendations\n\n"
        for rec in check_result['recommendations']:
            report += f"- {rec}\n"
        
        return report

    def check_dependency_licenses(self, requirements: Dict[str, str]) -> Dict[str, Any]:
        """Check licenses of dependencies (for compliance)."""
        
        license_database = self._load_license_database()
        
        licenses = {}
        restricted_licenses = []
        
        for package in requirements.keys():
            license_info = license_database.get(package.lower(), {})
            license_type = license_info.get('license', 'Unknown')
            
            if license_type not in licenses:
                licenses[license_type] = []
            licenses[license_type].append(package)
            
            # Check for restricted licenses
            if license_info.get('restricted', False):
                restricted_licenses.append({
                    "package": package,
                    "license": license_type,
                    "reason": license_info.get('restriction_reason', 'Check license compatibility')
                })
        
        return {
            "licenses_found": licenses,
            "restricted_licenses": restricted_licenses,
            "recommendation": "Review restricted licenses for compliance" if restricted_licenses else "License compliance OK"
        }

    # ===== Private Methods =====

    def _load_cve_database(self) -> List[Dict[str, Any]]:
        """Load simulated CVE database."""
        
        return [
            {
                "cve_id": "CVE-2021-34552",
                "package": "pillow",
                "severity": "CRITICAL",
                "description": "Excessive CPU use in PSD image parsing",
                "affected_versions": ["<=8.2.0"],
                "fixed_version": "8.3.0",
                "cvss_score": 7.5,
                "publication_date": "2021-07-02",
                "cwe_ids": ["CWE-834"]
            },
            {
                "cve_id": "CVE-2019-11236",
                "package": "requests",
                "severity": "HIGH",
                "description": "urllib3 contained a vulnerability where request body was not properly reloaded",
                "affected_versions": ["<2.22.0"],
                "fixed_version": "2.22.0",
                "cvss_score": 8.1,
                "publication_date": "2019-04-12",
                "cwe_ids": ["CWE-200"]
            },
            {
                "cve_id": "CVE-2020-26116",
                "package": "django",
                "severity": "MEDIUM",
                "description": "HTTP request smuggling via whitespace in headers",
                "affected_versions": ["<1.11.29", "2.0.*", "<2.2.18", "3.0.*", "<3.0.11"],
                "fixed_version": "3.1.0",
                "cvss_score": 6.5,
                "publication_date": "2020-09-23",
                "cwe_ids": ["CWE-444"]
            },
            {
                "cve_id": "CVE-2021-3129",
                "package": "flask",
                "severity": "CRITICAL",
                "description": "Remote code execution through Werkzeug debug PIN bypass",
                "affected_versions": ["<1.1.26"],
                "fixed_version": "1.1.26",
                "cvss_score": 9.8,
                "publication_date": "2021-02-15",
                "cwe_ids": ["CWE-94"]
            },
            {
                "cve_id": "CVE-2021-21240",
                "package": "pyyaml",
                "severity": "HIGH",
                "description": "Unsafe deserialization in YAML",
                "affected_versions": ["<5.4"],
                "fixed_version": "5.4",
                "cvss_score": 7.2,
                "publication_date": "2021-02-01",
                "cwe_ids": ["CWE-502"]
            },
            {
                "cve_id": "CVE-2022-24765",
                "package": "git",
                "severity": "HIGH",
                "description": "Git command injection through repository names",
                "affected_versions": ["<2.33", "2.34.*", "<2.34.1"],
                "fixed_version": "2.34.1",
                "cvss_score": 7.6,
                "publication_date": "2022-04-12",
                "cwe_ids": ["CWE-78"]
            }
        ]

    def _load_license_database(self) -> Dict[str, Dict[str, Any]]:
        """Load license information database."""
        
        return {
            "requests": {"license": "Apache 2.0", "restricted": False},
            "django": {"license": "BSD 3-Clause", "restricted": False},
            "flask": {"license": "BSD 3-Clause", "restricted": False},
            "pillow": {"license": "HPND", "restricted": False},
            "pyyaml": {"license": "MIT", "restricted": False},
            "sqlite": {"license": "Public Domain", "restricted": False},
            "affero": {"license": "AGPL", "restricted": True, "restriction_reason": "Requires source code sharing"},
            "proprietary": {"license": "Proprietary", "restricted": True, "restriction_reason": "Commercial use prohibited"}
        }

    def _is_vulnerable(self, installed_version: str, affected_versions: List[str]) -> bool:
        """Check if installed version is in affected range."""
        
        for affected in affected_versions:
            # Simplified version comparison (in production, use packaging.version)
            if affected == "*":
                return True
            elif affected.startswith("<="):
                affected_v = affected[2:]
                if self._compare_versions(installed_version, affected_v) <= 0:
                    return True
            elif affected.startswith("<"):
                affected_v = affected[1:]
                if self._compare_versions(installed_version, affected_v) < 0:
                    return True
            elif affected.startswith(">="):
                affected_v = affected[2:]
                if self._compare_versions(installed_version, affected_v) >= 0:
                    return True
            elif affected.startswith(">"):
                affected_v = affected[1:]
                if self._compare_versions(installed_version, affected_v) > 0:
                    return True
            elif affected == installed_version:
                return True
        
        return False

    def _compare_versions(self, v1: str, v2: str) -> int:
        """Simple version comparison."""
        
        parts1 = [int(x) if x.isdigit() else x for x in v1.split('.')]
        parts2 = [int(x) if x.isdigit() else x for x in v2.split('.')]
        
        for p1, p2 in zip(parts1, parts2):
            if isinstance(p1, int) and isinstance(p2, int):
                if p1 < p2:
                    return -1
                elif p1 > p2:
                    return 1
        
        if len(parts1) < len(parts2):
            return -1
        elif len(parts1) > len(parts2):
            return 1
        
        return 0

    def _generate_upgrade_recommendations(self, vulnerable_packages: List[Dict]) -> List[str]:
        """Generate upgrade recommendations."""
        
        recommendations = []
        
        for pkg in vulnerable_packages:
            has_critical = any(v['severity'] == 'CRITICAL' for v in pkg['vulnerabilities'])
            
            if has_critical:
                recommendations.append(f"Upgrade {pkg['package']} immediately - critical vulnerabilities found")
            else:
                fixed_version = pkg['vulnerabilities'][0]['fixed_version']
                recommendations.append(f"Upgrade {pkg['package']} to {fixed_version}")
        
        return recommendations

    def _assess_package_risk(self, vulns: List) -> str:
        """Assess risk level of a package."""
        
        if not vulns:
            return "LOW"
        
        critical_count = sum(1 for v in vulns if v['severity'] == 'CRITICAL')
        if critical_count > 0:
            return "CRITICAL"
        
        high_count = sum(1 for v in vulns if v['severity'] == 'HIGH')
        if high_count > 2:
            return "HIGH"
        elif high_count > 0:
            return "MEDIUM"
        
        return "LOW"

    def _recommend_package_usage(self, vulns: List) -> str:
        """Recommend whether to use a package."""
        
        risk = self._assess_package_risk(vulns)
        
        if risk == "CRITICAL":
            return "Do not use - critical vulnerabilities present"
        elif risk == "HIGH":
            return "Use with caution - plan upgrades"
        elif risk == "MEDIUM":
            return "Use - schedule updates"
        else:
            return "Safe to use"


if __name__ == "__main__":
    checker = CVEChecker()
    
    requirements = {
        "requests": "2.25.0",
        "django": "2.2.0",
        "flask": "1.1.0"
    }
    
    result = checker.check_requirements_file(requirements)
    
    import json
    print(json.dumps(result, indent=2, default=str))
