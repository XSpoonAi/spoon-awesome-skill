#!/usr/bin/env python3
"""
Remediation Suggester
Provides code-level remediation suggestions for vulnerabilities
"""

from typing import Dict, List, Any, Tuple

class RemediationSuggester:
    """Suggests remediation strategies and code fixes for vulnerabilities."""

    def __init__(self):
        self.remediation_templates = self._load_remediation_templates()

    def suggest_remediation(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Suggest remediation for a single vulnerability."""
        
        vuln_type = vulnerability.get('type', '')
        
        suggestion_method = getattr(self, f'_remediate_{vuln_type}', None)
        if suggestion_method:
            return suggestion_method(vulnerability)
        
        return self._generic_remediation(vulnerability)

    def suggest_multiple_remediations(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Suggest remediations for multiple vulnerabilities."""
        
        remediations = []
        for vuln in vulnerabilities:
            remediation = self.suggest_remediation(vuln)
            remediations.append(remediation)
        
        # Sort by priority and effort
        remediations.sort(key=lambda x: (x.get('priority', 'LOW'), x.get('estimated_effort_hours', 999)))
        
        return remediations

    def generate_remediation_plan(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate a remediation plan for all vulnerabilities."""
        
        remediations = self.suggest_multiple_remediations(vulnerabilities)
        
        # Group by phase
        immediate = [r for r in remediations if r.get('priority') == 'CRITICAL']
        short_term = [r for r in remediations if r.get('priority') == 'HIGH']
        medium_term = [r for r in remediations if r.get('priority') == 'MEDIUM']
        long_term = [r for r in remediations if r.get('priority') == 'LOW']
        
        total_hours = sum(r.get('estimated_effort_hours', 0) for r in remediations)
        total_days = total_hours / 8  # Assuming 8-hour workdays
        
        return {
            "summary": {
                "total_vulnerabilities": len(vulnerabilities),
                "total_estimated_hours": total_hours,
                "total_estimated_days": round(total_days, 1),
                "total_estimated_weeks": round(total_days / 5, 1)
            },
            "phases": {
                "immediate": {
                    "count": len(immediate),
                    "items": immediate,
                    "deadline": "Before next deployment"
                },
                "short_term": {
                    "count": len(short_term),
                    "items": short_term,
                    "deadline": "Within 2 weeks"
                },
                "medium_term": {
                    "count": len(medium_term),
                    "items": medium_term,
                    "deadline": "Within 2 months"
                },
                "long_term": {
                    "count": len(long_term),
                    "items": long_term,
                    "deadline": "Within 6 months"
                }
            },
            "implementation_strategy": self._generate_implementation_strategy(remediations)
        }

    def generate_secure_code_examples(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Generate before/after code examples for vulnerability remediation."""
        
        vuln_type = vulnerability.get('type', '')
        
        examples = {
            "sql_injection": {
                "vulnerable_code": """
# Vulnerable: String concatenation
user_id = request.args['id']
query = f"SELECT * FROM users WHERE id = {user_id}"
result = db.execute(query)
""",
                "secure_code": """
# Secure: Parameterized query
user_id = request.args['id']
query = "SELECT * FROM users WHERE id = ?"
result = db.execute(query, (user_id,))
""",
                "explanation": "Parameterized queries separate SQL logic from data, preventing injection attacks"
            },
            "command_injection": {
                "vulnerable_code": """
# Vulnerable: Shell command with concatenation
user_file = request.args['file']
os.system(f"ls {user_file}")
""",
                "secure_code": """
# Secure: subprocess with list arguments
import subprocess
user_file = request.args['file']
subprocess.run(['ls', user_file], shell=False)
""",
                "explanation": "Using list arguments and shell=False prevents shell interpretation"
            },
            "path_traversal": {
                "vulnerable_code": """
# Vulnerable: Direct path concatenation
file_path = request.args['file']
with open(f"/uploads/{file_path}") as f:
    return f.read()
""",
                "secure_code": """
# Secure: Path normalization and validation
import os
file_path = os.path.normpath(request.args['file'])
base_dir = "/uploads/"
full_path = os.path.join(base_dir, file_path)

# Ensure the resolved path is within base_dir
if not full_path.startswith(base_dir):
    raise ValueError("Invalid file path")

with open(full_path) as f:
    return f.read()
""",
                "explanation": "Normalize and validate paths to prevent directory traversal attacks"
            },
            "xss": {
                "vulnerable_code": """
# Vulnerable: Unescaped template variable
{{ user_input }}
""",
                "secure_code": """
# Secure: Enable auto-escaping in Jinja2
{{ user_input | escape }}
""",
                "explanation": "Auto-escaping converts HTML special characters to entities"
            },
            "insecure_deserialization": {
                "vulnerable_code": """
# Vulnerable: pickle with untrusted data
import pickle
data = request.data
obj = pickle.loads(data)  # RCE risk!
""",
                "secure_code": """
# Secure: Use JSON instead
import json
data = request.data
obj = json.loads(data)
""",
                "explanation": "JSON is safe for untrusted data; never unpickle untrusted input"
            },
            "hardcoded_secrets": {
                "vulnerable_code": """
# Vulnerable: Hardcoded credentials
API_KEY = "sk_live_a1b2c3d4e5f6g7h8i9j0"
db_password = "MySecretPassword123"
""",
                "secure_code": """
# Secure: Use environment variables
import os
API_KEY = os.environ.get('API_KEY')
db_password = os.environ.get('DB_PASSWORD')
""",
                "explanation": "Store secrets in environment variables or secrets manager, not in code"
            },
            "weak_cryptography": {
                "vulnerable_code": """
# Vulnerable: MD5 hash
import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()
""",
                "secure_code": """
# Secure: Use bcrypt for passwords
import bcrypt
password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())
""",
                "explanation": "Use strong, purpose-built algorithms (bcrypt for passwords, SHA-256+ for hashing)"
            },
            "missing_authentication": {
                "vulnerable_code": """
# Vulnerable: No authentication
@app.route('/api/admin')
def admin_panel():
    return render_template('admin.html')
""",
                "secure_code": """
# Secure: Add authentication check
from flask_login import login_required

@app.route('/api/admin')
@login_required
def admin_panel():
    return render_template('admin.html')
""",
                "explanation": "Use authentication decorators to protect sensitive endpoints"
            },
            "missing_input_validation": {
                "vulnerable_code": """
# Vulnerable: No input validation
email = request.form['email']
age = request.form['age']
user = create_user(email, age)
""",
                "secure_code": """
# Secure: Validate input
from wtforms import Form, StringField, IntegerField, validators

class UserForm(Form):
    email = StringField('email', [validators.Email()])
    age = IntegerField('age', [validators.NumberRange(min=0, max=150)])

form = UserForm(request.form)
if form.validate():
    user = create_user(form.email.data, form.age.data)
""",
                "explanation": "Validate and sanitize all user input before processing"
            }
        }
        
        return examples.get(vuln_type, {
            "vulnerable_code": "# Vulnerable code example",
            "secure_code": "# Secure code example",
            "explanation": "Use appropriate security controls"
        })

    def get_security_tools_recommendation(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Recommend security tools based on vulnerabilities found."""
        
        tools = []
        
        vuln_types = set(v.get('type') for v in vulnerabilities)
        
        if any(t in vuln_types for t in ['sql_injection', 'command_injection', 'xss']):
            tools.append({
                "name": "SAST - Static Analysis Security Testing",
                "examples": ["Bandit", "SonarQube", "Checkmarx"],
                "purpose": "Detect vulnerabilities in source code",
                "estimated_cost": "$1K-$50K/year"
            })
        
        if 'hardcoded_secrets' in vuln_types:
            tools.append({
                "name": "Secret Management",
                "examples": ["HashiCorp Vault", "AWS Secrets Manager", "Azure Key Vault"],
                "purpose": "Securely store and manage secrets",
                "estimated_cost": "$1K-$20K/year"
            })
        
        if 'missing_input_validation' in vuln_types:
            tools.append({
                "name": "WAF - Web Application Firewall",
                "examples": ["ModSecurity", "AWS WAF", "Cloudflare WAF"],
                "purpose": "Protect against injection and other web attacks",
                "estimated_cost": "$5K-$50K/year"
            })
        
        if any(t in vuln_types for t in ['weak_cryptography', 'insecure_random']):
            tools.append({
                "name": "Cryptography Library Audits",
                "examples": ["Dependency-Check", "Snyk", "Dependabot"],
                "purpose": "Find vulnerable dependencies",
                "estimated_cost": "$0-$10K/year"
            })
        
        if not tools:
            tools.append({
                "name": "General Security Scanning",
                "examples": ["OWASP ZAP", "Burp Suite Community"],
                "purpose": "General-purpose security testing",
                "estimated_cost": "$0-$5K/year"
            })
        
        return tools

    # ===== Private Methods =====

    def _load_remediation_templates(self) -> Dict[str, str]:
        """Load remediation templates."""
        return {}

    def _remediate_sql_injection(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": "sql_injection",
            "priority": "CRITICAL",
            "estimated_effort_hours": 4,
            "fix_approaches": [
                "Use parameterized queries / prepared statements",
                "Use ORM frameworks (SQLAlchemy, Django ORM)",
                "Input validation and escaping (less secure but still better)"
            ],
            "code_example": self.generate_secure_code_examples(vuln),
            "testing_approach": "Use OWASP ZAP or SQLMap to verify fix",
            "references": ["CWE-89", "OWASP A03:2021"]
        }

    def _remediate_command_injection(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": "command_injection",
            "priority": "CRITICAL",
            "estimated_effort_hours": 3,
            "fix_approaches": [
                "Use subprocess.run() with shell=False and list arguments",
                "Avoid os.system() and os.popen()",
                "Use language-specific safe APIs"
            ],
            "code_example": self.generate_secure_code_examples(vuln),
            "testing_approach": "Test with special characters and command separators",
            "references": ["CWE-78", "OWASP A03:2021"]
        }

    def _remediate_path_traversal(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": "path_traversal",
            "priority": "HIGH",
            "estimated_effort_hours": 3,
            "fix_approaches": [
                "Use os.path.normpath() and validate against base directory",
                "Implement whitelist of allowed files",
                "Use secure path manipulation libraries"
            ],
            "code_example": self.generate_secure_code_examples(vuln),
            "testing_approach": "Test with ../ sequences and absolute paths",
            "references": ["CWE-22", "OWASP A01:2021"]
        }

    def _remediate_xss(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": "xss",
            "priority": "HIGH",
            "estimated_effort_hours": 2,
            "fix_approaches": [
                "Enable auto-escaping in template engines",
                "Use Content Security Policy (CSP) headers",
                "Input validation and output encoding"
            ],
            "code_example": self.generate_secure_code_examples(vuln),
            "testing_approach": "Inject <script> tags and verify escaping",
            "references": ["CWE-79", "OWASP A07:2021"]
        }

    def _remediate_insecure_deserialization(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": "insecure_deserialization",
            "priority": "CRITICAL",
            "estimated_effort_hours": 6,
            "fix_approaches": [
                "Replace pickle with JSON",
                "Use type restrictions in YAML/XML parsers",
                "Validate data format before deserialization"
            ],
            "code_example": self.generate_secure_code_examples(vuln),
            "testing_approach": "Attempt to deserialize malicious payloads",
            "references": ["CWE-502", "OWASP A08:2021"]
        }

    def _remediate_hardcoded_secrets(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": "hardcoded_secrets",
            "priority": "CRITICAL",
            "estimated_effort_hours": 1.5,
            "fix_approaches": [
                "Move to environment variables",
                "Use secrets management system (Vault, AWS Secrets Manager)",
                "Rotate all exposed secrets immediately"
            ],
            "code_example": self.generate_secure_code_examples(vuln),
            "testing_approach": "Scan git history for exposed secrets",
            "references": ["CWE-798", "OWASP A02:2021"]
        }

    def _remediate_weak_cryptography(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": "weak_cryptography",
            "priority": "HIGH",
            "estimated_effort_hours": 4,
            "fix_approaches": [
                "Use bcrypt/scrypt for passwords",
                "Use SHA-256 or BLAKE2 for hashing",
                "Use AES-GCM for encryption"
            ],
            "code_example": self.generate_secure_code_examples(vuln),
            "testing_approach": "Verify strong algorithms are used",
            "references": ["CWE-327", "OWASP A02:2021"]
        }

    def _remediate_missing_authentication(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": "missing_authentication",
            "priority": "HIGH",
            "estimated_effort_hours": 4,
            "fix_approaches": [
                "Add @login_required or auth middleware",
                "Implement JWT or session-based authentication",
                "Add authentication checks to all endpoints"
            ],
            "code_example": self.generate_secure_code_examples(vuln),
            "testing_approach": "Verify endpoints reject unauthenticated requests",
            "references": ["CWE-306", "OWASP A07:2021"]
        }

    def _remediate_missing_input_validation(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": "missing_input_validation",
            "priority": "MEDIUM",
            "estimated_effort_hours": 3,
            "fix_approaches": [
                "Use input validation libraries (WTForms, Marshmallow)",
                "Implement allow-lists for expected input",
                "Sanitize output based on context"
            ],
            "code_example": self.generate_secure_code_examples(vuln),
            "testing_approach": "Test with invalid, boundary, and attack inputs",
            "references": ["CWE-20", "OWASP A03:2021"]
        }

    def _generic_remediation(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "vulnerability_type": vuln.get('type', 'unknown'),
            "priority": vuln.get('severity', 'MEDIUM'),
            "estimated_effort_hours": 3,
            "fix_approaches": [vuln.get('remediation', 'Apply security controls')],
            "code_example": {"explanation": "See security documentation"},
            "testing_approach": "Verify vulnerability is fixed",
            "references": [vuln.get('cwe_id', 'Unknown')]
        }

    def _generate_implementation_strategy(self, remediations: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate implementation strategy."""
        
        critical_count = sum(1 for r in remediations if r.get('priority') == 'CRITICAL')
        
        strategy = {
            "approach": "Phased remediation" if len(remediations) > 10 else "Parallel remediation",
            "team_involvement": ["Security", "Development"] if critical_count > 0 else ["Development"],
            "communication": {
                "stakeholder_update_frequency": "Daily" if critical_count > 0 else "Weekly",
                "progress_reporting": "Executive summary required" if critical_count > 0 else "Standard"
            },
            "quality_assurance": {
                "security_testing_required": True,
                "code_review_required": True,
                "deployment_approval": "Required" if critical_count > 0 else "Recommended"
            }
        }
        
        return strategy


if __name__ == "__main__":
    suggester = RemediationSuggester()
    
    vulnerabilities = [
        {
            "type": "sql_injection",
            "severity": "CRITICAL",
            "description": "SQL injection in user query"
        }
    ]
    
    plan = suggester.generate_remediation_plan(vulnerabilities)
    
    import json
    print(json.dumps(plan, indent=2))
