#!/usr/bin/env python3
"""
Unit Test Generator - Auto-generate pytest skeletons.

Author: SpoonOS Contributor
Version: 1.0.0
"""

import ast
import os
import sys
import json
from typing import List, Dict, Any

# Attempt to import BaseTool, handle running standalone for testing
try:
    from spoon_ai.tools.base import BaseTool
except ImportError:
    from pydantic import BaseModel, Field
    class BaseTool(BaseModel):
        name: str
        description: str
        parameters: dict
        async def execute(self, **kwargs): pass

from pydantic import Field

class TestGeneratorTool(BaseTool):
    name: str = "generate_tests"
    description: str = "Generates a pytest skeleton for a given Python file."
    parameters: dict = Field(default={
        "type": "object",
        "properties": {
            "file_path": {
                "type": "string",
                "description": "Path to the python source file"
            },
            "output_dir": {
                "type": "string",
                "description": "Directory to save the test file (default: tests/)",
                "default": "tests"
            },
            "force": {
                "type": "boolean",
                "description": "Overwrite existing test file",
                "default": False
            }
        },
        "required": ["file_path"]
    })

    async def execute(self, file_path: str, output_dir: str = "tests", force: bool = False) -> str:
        """
        Parses the python file and generates tests.
        """
        if not os.path.exists(file_path):
            return f"Error: File '{file_path}' not found."

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                tree = ast.parse(f.read())
        except Exception as e:
            return f"Error parsing file: {e}"

        filename = os.path.basename(file_path)
        module_name = filename.replace(".py", "")
        test_filename = f"test_{filename}"
        
        # Ensure output directory exists
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            
        test_file_path = os.path.join(output_dir, test_filename)
        
        if os.path.exists(test_file_path) and not force:
            return f"Error: Test file '{test_file_path}' already exists. Use force=True to overwrite."

        tests = []
        
        # Helper to generate test function code
        def create_test_func(name, original_name, context=""):
            return f"""
def test_{name}():
    \"\"\"
    Test for {context}{original_name}
    \"\"\"
    # TODO: Implement test
    assert True
"""

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                # Skip private functions or dunder methods usually
                if not node.name.startswith("_"):
                    tests.append(create_test_func(node.name, node.name, "function "))
            elif isinstance(node, ast.ClassDef):
                for item in node.body:
                    if isinstance(item, ast.FunctionDef):
                        if not item.name.startswith("_") or item.name == "__init__":
                             clean_name = f"{node.name}_{item.name}"
                             if item.name == "__init__":
                                 clean_name = f"{node.name}_init"
                             tests.append(create_test_func(clean_name, item.name, f"method {node.name}."))

        if not tests:
            return f"No public functions or classes found in {file_path} to test."

        # Generate file content
        content = f"""import pytest
from {module_name} import *

# Generated by SpoonOS Test Generator
"""
        content += "\n".join(tests)

        try:
            with open(test_file_path, "w", encoding="utf-8") as f:
                f.write(content)
        except Exception as e:
            return f"Error writing test file: {e}"

        return json.dumps({
            "message": "Test generation successful",
            "generated_file": test_file_path,
            "stats": {"tests_generated": len(tests)}
        }, indent=2)

if __name__ == "__main__":
    import asyncio
    
    async def main():
        tool = TestGeneratorTool()
        if len(sys.argv) > 1:
            target = sys.argv[1]
            print(f"Generating tests for {target}...")
            res = await tool.execute(file_path=target, output_dir=".")
            print(res)
        else:
            print("Usage: python generate_tests.py <file_path>")

    asyncio.run(main())
